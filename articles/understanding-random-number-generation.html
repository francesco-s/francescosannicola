<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Francesco Sannicola is a Machine Learning specialist and Software Engineer combining AI expertise with robust engineering practices. Discover projects spanning algorithms, intelligent systems, and advanced development."
    />
    <meta
      name="keywords"
      content="portfolio, machine learning, software, cloud, amazon web service, engineering"
    />
    <meta name="author" content="Francesco Sannicola" />
    <meta
      property="og:title"
      content="Francesco Sannicola - Machine Learning Engineer"
    />
    <meta
      property="og:description"
      content="Discover Francesco Sannicola’s portfolio showcasing software engineering expertise and cutting-edge Artificial Intelligence (AI) projects."
    />
    <meta
      property="og:url"
      content="https://www.francescosannicola.com/articles"
    />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="./assets/francescosannicola.jpg" />
    <title>Francesco Sannicola - Understanding Random Number Generation</title>
    <link rel="icon" type="image/x-icon" href="../favicon.ico" />
    <script
      type="text/javascript"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <link rel="stylesheet" type="text/css" href="../style.css" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="main-container">
      <div class="left-column">
        <header>
          <div class="header-left">
            <h1>Francesco Sannicola</h1>
            <h4 class="role">Machine Learning | Software Engineering</h4>
          </div>

          <div class="header-right">
            <div class="contact-info">
              <a href="../resume.pdf" target="_blank" aria-label="View Resume">
                <svg
                  fill="#000000"
                  version="1.1"
                  id="Capa_1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  width="18"
                  height="18"
                  viewBox="0 0 45.057 45.057"
                  xml:space="preserve"
                >
                  <title>Resume</title>
                  <g>
                    <g id="_x35_8_24_">
                      <g>
                        <path
                          d="M19.558,25.389c-0.067,0.176-0.155,0.328-0.264,0.455c-0.108,0.129-0.24,0.229-0.396,0.301
                                       c-0.156,0.072-0.347,0.107-0.57,0.107c-0.313,0-0.572-0.068-0.78-0.203c-0.208-0.137-0.374-0.316-0.498-0.541
                                       c-0.124-0.223-0.214-0.477-0.27-0.756c-0.057-0.279-0.084-0.564-0.084-0.852c0-0.289,0.027-0.572,0.084-0.853
                                       c0.056-0.281,0.146-0.533,0.27-0.756c0.124-0.225,0.29-0.404,0.498-0.541c0.208-0.137,0.468-0.203,0.78-0.203
                                       c0.271,0,0.494,0.051,0.666,0.154c0.172,0.105,0.31,0.225,0.414,0.361c0.104,0.137,0.176,0.273,0.216,0.414
                                       c0.04,0.139,0.068,0.25,0.084,0.33h2.568c-0.112-1.08-0.49-1.914-1.135-2.502c-0.644-0.588-1.558-0.887-2.741-0.895
                                       c-0.664,0-1.263,0.107-1.794,0.324c-0.532,0.215-0.988,0.52-1.368,0.912c-0.38,0.392-0.672,0.863-0.876,1.416
                                       c-0.204,0.551-0.307,1.165-0.307,1.836c0,0.631,0.097,1.223,0.288,1.77c0.192,0.549,0.475,1.021,0.847,1.422
                                       s0.825,0.717,1.361,0.949c0.536,0.23,1.152,0.348,1.849,0.348c0.624,0,1.18-0.105,1.668-0.312
                                       c0.487-0.209,0.897-0.482,1.229-0.822s0.584-0.723,0.756-1.146c0.172-0.422,0.259-0.852,0.259-1.283h-2.593
                                       C19.68,25.023,19.627,25.214,19.558,25.389z"
                        />
                        <polygon
                          points="26.62,24.812 26.596,24.812 25.192,19.616 22.528,19.616 25.084,28.184 28.036,28.184 30.713,19.616 28,19.616"
                        />
                        <path
                          d="M33.431,0H5.179v45.057h34.699V6.251L33.431,0z M36.878,42.056H8.179V3h23.706v4.76h4.992L36.878,42.056L36.878,42.056z"
                        />
                      </g>
                    </g>
                  </g>
                </svg>
                <span class="contact-label">Resume</span>
              </a>

              <a
                href="mailto:francescosannicola1997@gmail.com"
                aria-label="Send Email"
              >
                <svg
                  width="18"
                  height="21"
                  fill="#000000"
                  viewBox="0 0 1920 1920"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <title>Email</title>
                  <path
                    d="M0 1694.235h1920V226H0v1468.235ZM112.941 376.664V338.94H1807.06v37.723L960 1111.233l-847.059-734.57ZM1807.06 526.198v950.513l-351.134-438.89-88.32 70.475 378.353 472.998H174.042l378.353-472.998-88.32-70.475-351.134 438.89V526.198L960 1260.768l847.059-734.57Z"
                    fill-rule="evenodd"
                  />
                </svg>
                <span class="contact-label">Email</span>
              </a>

              <a
                href="https://www.linkedin.com/in/francesco-sannicola"
                target="_blank"
                aria-label="View LinkedIn Profile"
              >
                <svg
                  fill="#000000"
                  width="18"
                  height="18"
                  viewBox="0 0 1920 1920"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <title>LinkedIn</title>
                  <path
                    d="M1168 601.321v74.955c72.312-44.925 155.796-71.11 282.643-71.11 412.852 0 465.705 308.588 465.705 577.417v733.213L1438.991 1920v-701.261c0-117.718-42.162-140.06-120.12-140.06-74.114 0-120.12 23.423-120.12 140.06V1920l-483.604-4.204V601.32H1168Zm-687.52-.792v1318.918H0V600.53h480.48Zm-120.12 120.12H120.12v1078.678h240.24V720.65Zm687.52.792H835.267v1075.316l243.364 2.162v-580.18c0-226.427 150.51-260.18 240.24-260.18 109.55 0 240.24 45.165 240.24 260.18v580.18l237.117-2.162v-614.174c0-333.334-93.573-457.298-345.585-457.298-151.472 0-217.057 44.925-281.322 98.98l-16.696 14.173H1047.88V721.441ZM240.24 0c132.493 0 240.24 107.748 240.24 240.24 0 132.493-107.747 240.24-240.24 240.24C107.748 480.48 0 372.733 0 240.24 0 107.748 107.748 0 240.24 0Zm0 120.12c-66.186 0-120.12 53.934-120.12 120.12s53.934 120.12 120.12 120.12 120.12-53.934 120.12-120.12-53.934-120.12-120.12-120.12Z"
                    fill-rule="evenodd"
                  />
                </svg>
                <span class="contact-label">LinkedIn</span>
              </a>

              <a
                href="https://github.com/francesco-s"
                target="_blank"
                aria-label="View GitHub Profile"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  x="0px"
                  y="0px"
                  width="100"
                  height="100"
                  viewBox="0 0 24 24"
                >
                  <title>GitHub</title>
                  <path
                    d="M 12 1.9921875 C 6.4855957 1.9921875 2 6.4769321 2 12 C 2 16.599161 5.1205653 20.490345 9.3671875 21.642578 A 0.50005 0.50005 0 0 0 9.9980469 21.160156 L 9.9980469 17.583984 A 0.50005 0.50005 0 0 0 9.9980469 17.398438 L 9.9980469 17 C 9.9980469 16.463435 10.20474 15.989016 10.550781 15.621094 A 0.50005 0.50005 0 0 0 10.310547 14.794922 C 8.3191985 14.288505 7 12.945349 7 11.492188 C 7 10.73278 7.3615845 9.9960348 8.015625 9.3925781 A 0.50005 0.50005 0 0 0 8.1679688 8.9277344 C 8.066665 8.41934 8.082645 7.8782734 8.0742188 7.34375 C 8.6127591 7.5825374 9.1625862 7.7923277 9.640625 8.1757812 A 0.50005 0.50005 0 0 0 10.09375 8.265625 C 10.683558 8.0925899 11.325263 7.9921875 12 7.9921875 C 12.673669 7.9921875 13.314937 8.0917915 13.904297 8.265625 A 0.50005 0.50005 0 0 0 14.359375 8.1777344 C 14.837054 7.7945694 15.386932 7.5824899 15.925781 7.34375 C 15.916981 7.8785794 15.933881 8.4199143 15.832031 8.9277344 A 0.50005 0.50005 0 0 0 15.982422 9.3945312 C 16.637666 9.9982795 17.001953 10.733923 17.001953 11.494141 C 17.001953 12.945944 15.680991 14.28753 13.689453 14.794922 A 0.50005 0.50005 0 0 0 13.449219 15.623047 C 13.794633 15.990353 14.001953 16.464434 14.001953 17 L 13.998047 21.160156 A 0.50005 0.50005 0 0 0 14.630859 21.642578 C 18.878428 20.490372 22 16.599237 22 12 C 22 6.4769321 17.514404 1.9921875 12 1.9921875 z M 12 2.9921875 C 16.973596 2.9921875 21 7.0170679 21 12 C 21 15.899732 18.470363 19.145081 14.998047 20.388672 L 15.001953 17 C 15.001953 16.421513 14.688987 15.964437 14.404297 15.505859 C 16.432596 14.813419 18.001953 13.369173 18.001953 11.494141 C 18.001953 10.506223 17.528746 9.6094427 16.826172 8.8808594 C 16.963004 8.0965535 17.032667 7.2949738 16.970703 6.4570312 A 0.50005 0.50005 0 0 0 16.3125 6.0214844 C 15.491527 6.300863 14.703446 6.7215379 13.960938 7.2734375 C 13.34208 7.110241 12.692308 6.9921875 12 6.9921875 C 11.30618 6.9921875 10.656139 7.1108109 10.037109 7.2734375 C 9.2949426 6.7217093 8.5094793 6.2989123 7.6894531 6.0195312 A 0.50005 0.50005 0 0 0 7.0292969 6.4550781 C 6.9654142 7.294134 7.0380099 8.0939393 7.1738281 8.8769531 C 6.4709034 9.6061723 6 10.504427 6 11.492188 C 6 13.367279 7.5663139 14.813867 9.59375 15.505859 C 9.3112432 15.962509 9.0029789 16.419068 9 16.992188 L 7.5 16.992188 C 7.2241522 16.992188 7.0052524 16.845238 6.7363281 16.513672 C 6.4674039 16.182105 6.2065255 15.697988 5.9277344 15.234375 A 0.50005 0.50005 0 0 0 5.46875 14.988281 A 0.50005 0.50005 0 0 0 5.0722656 15.75 C 5.3304745 16.179387 5.5979086 16.697395 5.9589844 17.142578 C 6.3200601 17.587762 6.8328478 17.992188 7.5 17.992188 L 8.9980469 17.992188 L 8.9980469 20.388672 C 5.5278881 19.144471 3 15.898951 3 12 C 3 7.0170679 7.0264043 2.9921875 12 2.9921875 z"
                  ></path>
                </svg>
                <span class="contact-label">GitHub</span>
              </a>
            </div>
          </div>
          <div class="switch">
            <input type="checkbox" id="darkModeToggle" />
            <label for="darkModeToggle" class="switch-label">
              <span class="sun-icon">&#9728;</span>
              <!-- Sun icon (Light Mode) -->
              <span class="moon-icon">&#9790;</span>
              <!-- Moon icon (Dark Mode) -->
            </label>
          </div>
        </header>
      </div>
    </div>
    <div class="link-container">
      <div class="link-column">
        <a href="../"> <i class="fas fa-home"></i>Home </a>
      </div>
      <div class="link-column">
        <a href="../projects/overview.html">
          <i class="fas fa-project-diagram"></i>Projects
        </a>
      </div>
      <div class="link-column">
        <!--<a href="https://d1jdvilibzz056.cloudfront.net/articles/">-->
        <a href="overview.html"> <i class="fas fa-newspaper"></i>Articles </a>
      </div>
      <div class="link-column">
        <a href="../about.html"> <i class="fas fa-user"></i>About </a>
      </div>
    </div>
    <div class="article-container">
      <h1>
        <span style="font-size: 16px">./articles/</span> Understanding Random
        Number Generation
      </h1>
      <div class="last-updated">
        <span class="last-updated-label">Last modified:</span>
        <time datetime="2025-03-09">December 17, 2024</time>
      </div>

      <p>
        Despite its everyday use, the mechanics of Random Number Generation
        (RNG) are often misunderstood, particularly in determining how
        "randomness" is generated and ensuring its reliability across different
        use cases. In this article, we will explore two common random number
        generators (RNGs): the Linear Congruential Generator
        (<strong>LCG</strong>) and the Permuted Congruential Generator
        (<strong>PCG</strong>). But first let's understand what "random" means.
      </p>
      <p>
        If your question is: are there truly random algorithms? I want to tell
        you bad news. Algorithms are not truly random because they are
        inherently deterministic by design. True randomness originates from
        unpredictable, non-deterministic sources, while algorithms—being sets of
        defined instructions—cannot achieve this unpredictability.
      </p>
      <p>
        A fundamental characteristic of an algorithm is that it consistently
        produces the same output given the same input. This reproducibility
        allows outcomes to be replicated and even predicted, setting them apart
        from true randomness. Furthermore, algorithms operate within a finite
        computational environment, constrained by systems like integers or
        floating-point numbers with defined limits. These restrictions
        inevitably lead to repetition in the output, forming what is known as
        the period of a pseudo-random sequence.
      </p>
      <p>
        To approximate true randomness, external entropy sources must be
        incorporated. Cryptographically Secure Pseudo-Random Number Generators
        (CSPRNGs) employ this strategy by using entropy from unpredictable
        external sources, such as hardware random number generators (HRNGs). In
        contrast, Pseudo-Random Number Generators (<strong>PRNGs</strong>) rely
        entirely on an initial input or seed, producing outputs that only appear
        random. Techniques like the LCG and the PCG exemplify these methods,
        which we will implement later.
      </p>
      <p>
        True Random Number Generators (<strong>TRNGs</strong>), however, derive
        randomness from physical phenomena, such as atmospheric noise,
        radioactive decay, or thermal fluctuations. These sources are inherently
        unpredictable, yielding a higher degree of randomness compared to
        algorithmic approaches.
      </p>
      <p>
        Therefore, our focus will remain on PRNGs and their deterministic, yet
        practical, approach to generating sequences that approximate randomness.
      </p>

      <div class="summary">
        <h4>Quick Navigation</h4>
        <ol>
          <li><a href="#lcg">Linear Congruential Generator (LCG)</a></li>
          <li><a href="#pcg">Permuted Congruential Generator (PCG)</a></li>
          <li><a href="#implementations">Python implementations</a></li>
          <li><a href="#considerations">Considerations</a></li>
        </ol>
      </div>

      <h2 id="lcg">1. Linear Congruential Generator (LCG)</h2>
      <p>
        The Linear Congruential Generator (LCG) is a widely-used and simple
        pseudo-random number generator based on a linear recurrence relation:
      </p>
      <p class="responsive-math">\[ X_{n+1} = (a \cdot X_n + c) \mod m \]</p>
      <p>Where:</p>
      <ul>
        <li>
          <span>\(a\)</span>: The multiplier that determines how much the
          sequence progresses between consecutive numbers.
        </li>
        <li>
          <span>\(c\)</span>: The increment that introduces variability,
          preventing the sequence from falling into zero cycles.
        </li>
        <li>
          <span>\(m\)</span>: The modulus that sets the range of the generated
          numbers, often chosen as a power of 2 for computational efficiency.
        </li>
        <li>
          <span>\(X_n\)</span>: The current state, which can be either the
          initial seed or the previously generated number.
        </li>
      </ul>

      <p>
        Let's build a Linear Congruential Generator (LCG) from scratch in Python
        for simplicity. Our first task is to define a class called
        <code>LCGPseudoRand</code>, with constructor parameters for
        <code>a</code>, <code>c</code>, <code>m</code>, and <code>seed</code>.
        Here's the implementation:
      </p>

      <pre><code class="language-python">
    class LCGPseudoRand:
        def __init__(self, a=48271, c=0, m=2**31-1, seed=1):  # C++11 LCG parameters
            self.a = a
            self.c = c
            self.m = m
            self.x0 = seed
            # Compute the first value based on the seed
            self.prev_x = (a * self.x0 + c) % m
                </code></pre>

      <p>
        In this implementation, I've used the C++11 LCG parameters with a
        default seed value of <code>1</code>. The constructor also initializes
        the first value of the sequence using the LCG formula:
      </p>

      <pre><code class="language-python">
    self.prev_x = (a * self.x0 + c) % m
                </code></pre>

      <p>
        For example, if we create the object <code>lcg = LCGPseudoRand()</code>,
        the first value is calculated as:
      </p>
      <p class="responsive-math">(48271 * 1 + 0) % (2**31-1) = 48271</p>

      <p>
        The starting value of the sequence is <code>48271</code>. Now, let's add
        a method to generate the pseudo-random numbers based on the same
        formula:
      </p>

      <pre><code class="language-python">
    def generate_number(self, min_range=None, max_range=None):
        self.prev_x = (self.a * self.prev_x + self.c) % self.m
        return self.prev_x
                </code></pre>

      <p>
        The method updates the state using the LCG formula and returns the next
        number in the sequence. Let's generate 5 pseudo-random numbers and print
        them:
      </p>

      <pre><code class="language-python">
    lcg = LCGPseudoRand()
    for _ in range(5):
        print(lcg.generate_number())
                </code></pre>

      <p>The output will look like this:</p>

      <p class="responsive-math">
        182605794, 1291394886, 1914720637, 2078669041, 407355683
      </p>

      <p>We have successfully generated 5 pseudo-random numbers.</p>
      <ul>
        <li>
          The first element of the list is calculated as:
          <p class="responsive-math">
            (48271 * 48271 + 0) % 2147483647 = 182605794
          </p>
        </li>
        <li>
          The second element is calculated as:
          <p class="responsive-math">
            (48271 * 182605794 + 0) % 2147483647 = 1291394886
          </p>
        </li>
      </ul>

      <p>
        However, if you re-run the same code without changing the seed, the
        algorithm will produce the exact same sequence again. This is because
        LCGs are deterministic. Their output is entirely determined by the
        initial seed and the parameters <code>a</code>, <code>c</code>, and
        <code>m</code>.
      </p>

      <p>
        As we discussed earlier, a more unpredictable starting seed is required
        to avoid deterministic sequences. Atmospheric noise or radioactive decay
        might be difficult to integrate. A simple yet effective alternative is
        to combine the current time with the system's process ID. This method
        works well and ensures better randomness when initializing the
        generator's seed in the constructor.
      </p>

      <pre><code class="language-python">
    import os
    import time
    
    class LCGPseudoRand:
        def __init__(self, a=48271, c=0, m=2**31-1, seed=None):
            self.a = a
            self.c = c
            self.m = m
            if seed is None:
                self.x0 = int(os.getpid() + time.time())
            else:
                self.x0 = seed
            self.prev_x = (a * self.x0 + c) % m
                    </code></pre>

      <p>
        In this example, we've added functionality to automatically generate a
        unique seed if the user doesn't provide one. The line
        <code>self.x0 = int(os.getpid() + time.time())</code> combines the
        system's process ID with the current time to ensure that each execution
        generates a different seed.
      </p>
      <p>
        The <code>os.getpid()</code> function fetches the process ID of the
        current program, which is usually unique per running program. The
        <code>time.time()</code> function returns the current time in seconds
        since the epoch, which changes with each program execution. When you add
        these together and cast them to an integer, the result becomes a fairly
        unique seed that minimizes the likelihood of repeating values. Notice
        that each time the program runs, a new sequence is generated, thanks to
        our dynamic seed generation mechanism.
      </p>

      <p>
        When generating pseudo-random numbers with a LCG, it is often necessary
        to scale the output so that it falls within a specified range. For
        example, you may need a random number between 10 and 50, or between two
        user-defined values, such as <code>min_range</code> and
        <code>max_range</code>. By scaling the generated number, you can ensure
        that it fits within the desired bounds.
      </p>

      <p>The scaling formula is:</p>
      <p class="responsive-math">
        \[ \text{output} = \text{min_range} + \left( \frac{X_n}{m} \right)
        \times (\text{max_range} - \text{min_range}) \]
      </p>
      <p>
        In the following code snippet, we modify the previously generated
        pseudo-random number using a scaling formula to fit within the
        user-defined range:
      </p>
      <pre><code class="language-python">
    def generate_number(self, min_range=None, max_range=None):
        self.prev_x = (self.a * self.prev_x + self.c) % self.m
    
        if min_range is not None and max_range is not None:
            return int((self.prev_x / self.m) * (max_range - min_range) + min_range)
        else:
            return self.prev_x
                    </code></pre>

      <p>
        The <code>generate_number</code> method first calculates the next number
        in the sequence using the standard LCG formula, and then scales the
        result to fit within the specified <code>min_range</code> and
        <code>max_range</code>.
      </p>

      <p>
        Let’s consider an example where we generate random numbers between 10
        and 50:
      </p>

      <pre><code class="language-python">
    lcg = LCGPseudoRand()
    for _ in range(5):
        print(lcg.generate_number(10, 50))
                    </code></pre>

      <p>
        Each time this program runs, the output numbers will be scaled to the
        specified range (10 to 50).
      </p>

      <h4>Initialization Differences Between Programming Languages</h4>

      <p>
        The parameters \(a\), \(c\), and \(m\) directly affect the quality of
        randomness and the period of the LCG. A poorly chosen set of parameters
        may result in sequences with clear patterns or shorter-than-expected
        periods. To achieve the maximum period of \(m\), the following
        conditions must be met:
      </p>
      <ul>
        <li>The increment \(c\) must be relatively prime to \(m\).</li>
        <li>
          The multiplier \(a - 1\) must be divisible by all prime factors of
          \(m\).
        </li>
        <li>
          If \(m\) is a multiple of 4, \(a\) and \(m\) should share the same
          remainder when divided by 4.
        </li>
      </ul>

      <p>
        Different programming languages and libraries initialize LCGs using
        unique approaches to determine the initial seed \(X_0\), which impacts
        reproducibility and sequence variation:
      </p>

      <div class="responsive-table-container">
        <table border="1" cellpadding="8" cellspacing="0">
          <thead>
            <tr>
              <th>Language</th>
              <th>Initialization Mechanism</th>
              <th>Seed Parameters</th>
              <th>a (Multiplier)</th>
              <th>c (Increment)</th>
              <th>m (Modulus)</th>
              <th>Example Code</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Java</strong></td>
              <td>
                The `java.util.Random` class uses an LCG. Seeding is done using
                system time by default.
              </td>
              <td>
                Default seed is derived from the current time in milliseconds.
              </td>
              <td>25214903917</td>
              <td>11</td>
              <td>\(m = 2^{48}\)</td>
              <td>
                <pre><code>long seed = System.currentTimeMillis();</code></pre>
              </td>
            </tr>
            <tr>
              <td><strong>Borland C++</strong></td>
              <td>
                Uses the "std::linear_congruential_engine" from the
                &lt;random&gt; header, requiring explicit seed values.
              </td>
              <td>
                The seed value is provided by the user when creating the
                generator instance.
              </td>
              <td>22695477</td>
              <td>1</td>
              <td>\(m = 2^{31}\)</td>
              <td>
                <pre><code>#include &lt;random&gt;
            std::linear_congruential_engine&lt;unsigned, 16807, 0, 2147483647&gt; engine(12345);</code></pre>
              </td>
            </tr>
            <tr>
              <td><strong>C++11</strong></td>
              <td>The "std::minstd_rand" engine uses a LCG.</td>
              <td>
                The default seed is user-defined or zero if not explicitly
                initialized.
              </td>
              <td>48271</td>
              <td>0</td>
              <td>\(m = 2^{31} - 1\)</td>
              <td>
                <pre><code>#include &lt;random&gt;
    std::minstd_rand rng(42);</code></pre>
              </td>
            </tr>

            <tr>
              <td><strong>JavaScript</strong></td>
              <td>
                "Math.random()" abstracts away the seeding process and doesn't
                allow for user-defined seeds. Its underlying RNG algorithm might
                use LCG or a variation, but the details are not publicly exposed
                by JavaScript engines.
              </td>
              <td>
                No explicit seed from the user. The engine typically uses a
                system-based or time-based seed.
              </td>
              <td>Not accessible.</td>
              <td>Not accessible.</td>
              <td>Not accessible.</td>
              <td>
                No code for seeding, as direct seeding is not supported in
                `Math.random()`.
              </td>
            </tr>
            <tr>
              <td><strong>Python</strong></td>
              <td>
                Uses Mersenne Twister as the default generator in the "random"
                module (I'll try to cover Mersenne Twister in the future).
                Earlier versions (pre-2.2) might have used LCG for `random` but
                this is not standard in modern implementations.
              </td>
              <td>
                Common seeds include system time or a fixed integer provided by
                the user. For example, "random.seed(12345)` or just
                `random.seed()" for system time.
              </td>
              <td>
                Multiplier and increment used depend on the specific algorithm,
                but with Mersenne Twister, the details are not equivalent to a
                simple LCG (it’s a much more complex state transition). With
                older LCGs used for "random.seed()" there would be corresponding
                values for a and c but they are no longer part of the active
                algorithm in modern versions of Python.
              </td>
              <td>
                Fixed increment (for older LCG, if used), typically a constant.
              </td>
              <td>
                Uses internally defined modulus for Mersenne Twister. LCG
                implementations in older versions or different libraries might
                have \(m = 2^{32}\) or similar values.
              </td>
              <td>
                Example: "random.seed(12345)" initializes with a seed value.
                "random.seed()" with no argument uses system time.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h2 id="pcg">2. Permuted Congruential Generator (PCG)</h2>
      <p>
        The Permuted Congruential Generator (PCG) is a modern pseudo-random
        number generator that improves upon the classic Linear Congruential
        Generator (LCG). It combines a linear congruential generator with a
        permutation function to produce higher-quality random numbers with
        minimal computational overhead.
      </p>

      <p class="responsive-math">
        \[ \text{state}_{n+1} = (\text{state}_n \times \text{multiplier} +
        \text{increment}) \mod 2^{64} \]
      </p>

      <p>
        However, unlike the LCG, PCG applies a permutation step to the generated
        state to enhance randomness:
      </p>
      <p class="responsive-math">
        \[ \text{output} = ((\text{state} >> \text{shift}) \oplus \text{state})
        \mod 2^{64} \]
      </p>
      <p>Where:</p>
      <ul>
        <li><span>state</span>: The internal state of the generator.</li>
        <li>
          <span>multiplier</span>: A large odd number used in the linear step.
        </li>
        <li>
          <span>increment</span>: Another large odd number ensuring a full
          period.
        </li>
        <li>
          <span>shift</span>: A calculated bit-shift for scrambling the state.
        </li>
      </ul>

      <p>
        The constructor initializes the generator's parameters:
        <code>multiplier</code>, <code>increment</code>, and
        <code>modulus</code>. Like previously, if a seed is provided, it is used
        as the initial state; otherwise, the generator creates a unique seed by
        combining the process ID and the current time:
      </p>
      <pre><code class="language-python">
    class PCGPseudoRand:
        def __init__(self, multiplier=6364136223846793005, increment=1442695040888963407, seed=None) -> None:
            self.multiplier = multiplier
            self.increment = increment | 1
            self.modulus = 2**64
            if seed is not None:
                self.state = seed
            else:
                self.state = int(os.getpid() + time.time()) & 0xFFFFFFFFFFFFFFFF
    </code></pre>

      <p>
        In this implementation the multiplier, increment and modulus are from
        Donald Knuth's MMIX.
      </p>
      <p>
        The expression
        <code>int(os.getpid() + time.time()) & 0xFFFFFFFFFFFFFFFF</code>
        generates a pseudo-random 64-bit seed by combining the current process
        ID and the current time. This approach adds a level of non-determinism
        since the process ID and time are unlikely to repeat simultaneously
        (same way as LCG discussed earlier). The bitwise AND operation
        <code>& 0xFFFFFFFFFFFFFFFF</code> ensures that the resulting value is
        constrained to a 64-bit integer, even if the sum exceeds the 64-bit
        range.
      </p>

      <p>
        The Linear Congruential Step method updates the internal state using the
        LCG formula:
      </p>
      <pre><code class="language-python">
    def _lcg_step(self):
        self.state = (self.state * self.multiplier + self.increment) & 0xFFFFFFFFFFFFFFFF
    </code></pre>
      <p>
        The new state is calculated by multiplying the current state by the
        multiplier, adding the increment, and applying a modulo operation to
        ensure the value stays within a 64-bit range.
      </p>

      <p>
        Is it similar to an LCG? Yes, to some extent. However, there is an
        additional permutation step here, which does not exist in a standard
        LCG. This step involves the following:
      </p>
      <ol>
        <li>
          <p>
            The first step involves extracting key bits from the uppermost part
            of the 64-bit integer <code>x</code> to determine how much the
            number will be shifted. Specifically,
            <code>shift = (x &gt;&gt; 59) + 1</code> performs a right shift of
            <code>x</code> by 59 bits. Since <code>x</code> is a 64-bit integer,
            this operation isolates the top 5 bits (bits 59-63) after the shift.
          </p>
          <p>
            The result is a value between 0 and 31, as the top 5 bits form a
            5-bit binary number. Adding 1 ensures that the shift amount is
            always at least 1, preventing a shift by 0 bits, which would have no
            effect.
          </p>
        </li>
        <li>
          <p>
            Next, the bits of <code>x</code> are shifted to the right by the
            calculated <code>shift</code> amount. This operation discards the
            bits on the right and shifts in zeros on the left. The resulting
            value is then XORed with the original value of <code>x</code>. The
            XOR operation compares each corresponding bit of the shifted value
            and <code>x</code>, returning 1 if the bits differ and 0 if they are
            the same. This step introduces a mix of the bits, ensuring better
            scrambling of the number.
          </p>
        </li>
      </ol>

      <pre>
        <code class="language-python">
    def _permute(self, x):
        shift = (x >> 59) + 1
        return ((x >> shift) ^ x) & 0xFFFFFFFFFFFFFFFF</code>
    </pre>

      <p>
        Let's walk through the calculation step-by-step for the expression
        <span class="highlight">shift = (x &gt;&gt; 59) + 1</span>, where the
        number <span class="highlight">x = 0xF123456789ABCDEF</span>.
      </p>
      <p>
        The hexadecimal value
        <span class="highlight">x = 0xF123456789ABCDEF</span> is converted to
        binary:
      </p>
      <div class="responsive-code-container">
        <pre><code>
        x = 0xF123456789ABCDEF<br>
        In binary, x = 11110001001000110100010101100111000100111010111111011111
        </code></pre>
      </div>
      <p>
        The expression <span class="highlight">x &gt;&gt; 59</span> means
        shifting the bits of <span class="highlight">x</span> to the right by 59
        positions. This operation discards the 59 least significant bits and
        moves the remaining bits to the right.
      </p>
      <div class="responsive-code-container">
        <pre><code>
        x = 11110001001000110100010101100111000100111010111111011111<br>
        x &gt;&gt; 59 = 00000000000000000000000000000000000000000000000000000111
        </code></pre>
      </div>
      <p>
        Next, we compute the final value of
        <span class="highlight">shift</span>. The top 5 bits of
        <code>x</code> after shifting right by 59 are <code>111</code> in
        binary, which equals <code>7</code> in decimal. Adding
        <code>1</code> ensures a minimum shift value of <code>1</code>:
      </p>
      <div class="responsive-code-container">
        <pre><code>
        shift = (x &gt;&gt; 59) + 1 = 7 + 1 = 8
    </code></pre>
      </div>
      <p>
        Now, let’s calculate the expression
        <span class="highlight"
          >((x &gt;&gt; shift) ^ x) &amp; 0xFFFFFFFFFFFFFFFF</span
        >
        step by step.
      </p>

      <p>
        Shifting <code>x</code> to the right by <code>8</code> positions
        discards the least significant 8 bits, shifting zeros into the left:
      </p>
      <ul>
        <li>
          The original value of <code>x</code> in binary:
          <span class="responsive-math"
            >11110001001000110100010101100111000100111010111111011111</span
          >
        </li>
        <li>
          The shifted value (right shifted by 8 bits):
          <span class="responsive-math"
            >00000000111100010010001101000101011001110001001110101111</span
          >
        </li>
      </ul>

      <p>
        Performing the XOR operation between the original value
        <code>x</code> and the shifted value:
      </p>
      <div class="responsive-code-container">
        <pre><code>
        Original (x):   11110001001000110100010101100111000100111010111111011111
        Shifted:        00000000111100010010001101000101011001110001001110101111
        XOR result:     11110001110100100110011000100010011101001011110001110000
    </code></pre>
      </div>
      <p>
        In hexadecimal, the result of the XOR operation is:
        <span class="highlight">0xF1D2662274BC70</span>.
      </p>

      <p>
        Finally, the result is ANDed with <code>0xFFFFFFFFFFFFFFFF</code> to
        constrain it to 64 bits. Since the XOR result already fits within 64
        bits, the AND operation does not change the value:
      </p>
      <div class="responsive-code-container">
        <pre><code>
        ((x &gt;&gt; shift) ^ x) &amp; 0xFFFFFFFFFFFFFFFF = 0xF1D2662274BC70
        </code></pre>
      </div>
      <p>
        The final value is 0xF1D2662274BC70 or 68066805493841008 in decimal.
      </p>
      <p>
        This value represents a 64-bit unsigned integer, making it suitable for
        scaling to a desired range using the scaling formula:
      </p>
      <p class="responsive-math">
        \[ \text{output} = \text{min_range} + \left( \frac{P(S_n)}{2^{64}}
        \right) \times (\text{max_range} - \text{min_range}) \]
      </p>

      <ul>
        <li>
          <strong>\( P(S_n) \)</strong>: The 64-bit value to be scaled (e.g.,
          <code>0xF1D2662274BC70</code>).
        </li>
        <li>
          <strong>\( 2^{64} \)</strong>: The total range of possible 64-bit
          unsigned integers.
        </li>
        <li>
          <strong>\( \text{min_range} \)</strong> and
          <strong>\( \text{max_range} \)</strong>: The target range for scaling.
        </li>
      </ul>
      <p>
        The fraction \( \frac{P(S_n)}{2^{64}} \) normalizes the 64-bit integer
        value <code>P(S_n)</code> into the range <code>[0, 1)</code>.
        Multiplying this fraction by \( \text{max_range} - \text{min_range} \)
        scales it to the size of the target range. Adding \( \text{min_range} \)
        shifts the result to start at the desired minimum value.
      </p>

      <h2 id="implementations">3. Python implementations</h2>
      <pre><code class="language-python">
    class LCGPseudoRand():
        def __init__(self, a=48271, c=0, m=2**31-1, seed=None) -> None: # C++ version
            self.a = a
            self.c = c
            self.m = m
    
            if seed:
                self.x0 = seed
            else:
                self.x0 = int(os.getpid() + time.time())
            
            self.prev_x = (a * self.x0 + self.c) % self.m
        
        def generate_number(self, min_range=None, max_range=None):
    
            self.prev_x = (self.a * self.prev_x + self.c) % self.m
    
            if min_range and max_range:
                return int((self.prev_x / self.m) * (max_range - min_range) + min_range)
            else:
                return self.prev_x

    class PCGPseudoRand:
        def __init__(self, multiplier=6364136223846793005, increment=1442695040888963407, seed=None) -> None:
            self.multiplier = multiplier  
            self.increment = increment | 1 
            self.modulus = 2**64 
    
            
            if seed is not None:
                self.state = seed
            else:
                self.state = int(os.getpid() + time.time()) & 0xFFFFFFFFFFFFFFFF
        
        def _lcg_step(self):
            self.state = (self.state * self.multiplier + self.increment) & 0xFFFFFFFFFFFFFFFF
    
        def _permute(self, x):
            shift = (x >> 59) + 1
            return ((x >> shift) ^ x) & 0xFFFFFFFFFFFFFFFF

        def generate_number(self, min_range=None, max_range=None):
            self._lcg_step()
            
            permuted_value = self._permute(self.state)
            print(self.state, permuted_value)
    
            if min_range is not None and max_range is not None:
                return int((permuted_value / self.modulus) * (max_range - min_range) + min_range)
            else:
                return permuted_value
                      
            </code></pre>

      <h2 id="considerations">4. Considerations</h2>
      <p>
        While the Linear Congruential Generator (LCG) is faster and simpler to
        implement, it often suffers from lower randomness quality. LCGs generate
        sequences with a predictable structure.
      </p>
      <p>
        The Permuted Congruential Generator (PCG), on the other hand, introduces
        a permutation step on top of the basic linear congruential approach.
        This permutation step greatly improves randomness quality by better
        scrambling the bits of the generated numbers. Although PCG incurs a
        slight computational overhead compared to LCG, it is negligible for most
        use cases and worth the tradeoff for significantly better randomness
        properties.
      </p>
      <p>
        In the future, I hope to discuss the <strong>Mersenne Twister</strong>,
        another widely used pseudorandom number generator. Known for its
        extremely long period (2<sup>19937</sup> − 1) and excellent randomness
        properties, the Mersenne Twister addresses many shortcomings of earlier
        generators like LCG. Interestingly, the Mersenne Twister is the default
        pseudorandom number generator in Python's <code>random</code> module.
        Its widespread use stems from its efficiency, ability to produce
        high-quality randomness, and suitability for general-purpose random
        number generation.
      </p>
    </div>

    <button
      id="backToTopButton"
      onclick="scrollToTop()"
      style="font-size: 24px; padding: 10px 20px"
    >
      <i class="fa fa-arrow-up"></i>
    </button>

    <script>
      // Get stored dark mode state
      let isDarkMode = localStorage.getItem("darkMode") === "true";

      // Function to apply dark mode
      function applyDarkMode(dark) {
        const darkModeToggle = document.getElementById("darkModeToggle");
        const elements = [
          document.body,
          ...document.querySelectorAll(
            ".main-container, .info-container, .projects-container, .article-container, .link-container, .accordion, .code"
          ),
        ];

        // Update state
        isDarkMode = dark;
        localStorage.setItem("darkMode", dark);

        // Update UI
        elements.forEach((element) => {
          if (dark) {
            element.classList.add("dark-mode");
          } else {
            element.classList.remove("dark-mode");
          }
        });

        // Update toggle
        if (darkModeToggle) {
          darkModeToggle.checked = dark;
        }
      }

      // Initialize dark mode
      document.addEventListener("DOMContentLoaded", () => {
        const darkModeToggle = document.getElementById("darkModeToggle");

        // Apply initial state
        applyDarkMode(isDarkMode);

        // Handle toggle changes
        darkModeToggle.addEventListener("change", (e) => {
          applyDarkMode(e.target.checked);
        });
      });

      // Apply dark mode immediately if needed
      if (isDarkMode) {
        applyDarkMode(true);
      }

      // Back to Top Button Script
      function scrollToTop() {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
      }
      window.addEventListener("scroll", () => {
        const button = document.getElementById("backToTopButton");
        if (window.scrollY > 500) {
          button.style.display = "block";
        } else {
          button.style.display = "none";
        }
      });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  </body>
</html>
